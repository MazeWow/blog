# const 设置为只读
```c
const int days[6] = {12,23,45,32,35,34};
```

# 数组大小轮询
```c
const int days[] = {31,28,31,30,31,30,31,31,30,31,30,31};
for(int index = 0;index < sizeof(days) / sizeof(days[0]);index++){
    printf("days[%d] : %d\n",index,days[index]);
}
```

# 指定初始化器 C99标准
指定第6个元素的值为212
```c
int arr[6] = {0,89,[5]=212};
```

# 数组越界
gcc编译器只会给出警告,然后继续编译，越界处的值是随机的
```c
const int days[] = {31,28,31,30,31,30,31,31,30,31,30,31,[13]=67};
int index;
for(index = 0;index < sizeof(days) / sizeof(days[0]);index++){
    printf("days[%d] : %d,地址:%p \n",index,days[index],&days[index]);
}
// 越界数组
printf("days[-1]: %d,地址:%p \n",days[-1],&days[-1]);
printf("days[14]: %d,地址:%p \n",days[14],&days[14]);
```
为了防止数组出现越界的情况，使用符号常量申明数组是很有必要的
```c
#define SIZE 4
int main(){
    int arr[SIZE];
    // ...
}
```

# 数组赋值
c 不允许数组作为一个单元赋值给另一个数组
```c
int oxen[4] = {1,2,3,4};
int yaks[4];
yaks = oxen;
// main.c:28:7: error: assignment to expression with array type
//   yaks = oxen;
```

# 多维数组
```
float rain[5][12];
```
多维数组的存储顺序,先从第一个包含12个元素的数组开始，然后是第二个包含12个元素的数组
```c
const int rain[5][12] =
{
    {4,2,2,23,3,43,42,34,23,24,23,34},
    {4,2,2,23,3,43,42,34,23,24,23,34},
    {4,2,2,23,3,43,42,34,23,24,23,34},
    {4,2,2,23,3,43,42,34,23,24,23,34},
    {4,2,2,23,3,43,42,34,23,24,23,34}
};
for(int index1 = 0;index1 < 5;index1 ++){
    for(int index2 = 0;index2 < 12;index2++){
        printf("rain[%d][%d] : \t%p : \t%d\n",index1,index2,&rain[index1][index2],rain[index1][index2]);
    }
}
```

# 数组名
数组名是数组首元素的地址
```c
short dates[4];
short *p = dates;
``
# 对形式参数使用const
const告诉编译器，该函数不能修改arr指向的数组中的内容。如果在函数中不小心使用了类似于arr[i]++的操作,编译器会捕捉这个错误
```c
int sum(const int arr[],int n);
int sum(const int arr[],int n){
    // ...
}
```

# const 修饰符其他内容
修饰数组
```c
const int days[MONTHS] = {31,28,31,30,31,30,31,31};
days[3] = 31; // 编译错误
```
修饰指针
```c
double rates[5] = {22.21,21,43,45,39.01};
const double *pd = rates;
*pd = 29.11; // 编译错误
pd[2] = 29.11; // 编译错误
rates[0] = 29.11; // 正确 因为rates未被限定

// 表示该函数不会使用指针改变数据
void show_array(const double *ar,int n);

// 不能改变指针的指向
double * const pc = rates;
pc = &rates[2]; // 编译错误
*pc = 11; // 可以改变它指向处的值
```

# 指向多维数组的指针
```c
// 指向多维数组的指针
int zippo[3][2] =
{
    {2,3},
    {4,5},
    {6,7}
};
int (*pz)[2]; // 指向一个含有两个int类型值的数组
pz = zippo;
printf("pz = %p,pz + 1:%p \n",pz,pz+1);
printf("pz[0] = %p,pz[0] + 1:%p \n",pz[0],pz[0]+1);
printf("*pz = %p,*pz + 1:%p \n",*pz,*pz+1);
printf("**pz = %d,*(*pz + 1):%d \n",**pz,*(*pz+1));
printf("**(pz + 1) = %d,*(*(pz + 1) + 1):%d \n",**(pz + 1),*(*(pz + 1)+1));
printf("pz[0][0] = %d,pz[0][1]:%d \n",pz[0][0],pz[0][1]);
```
处理多维数组的函数
```c
void func(int pt[][4]); // pt指向的是一个包含4个int类型的一维数组
void func(int (*pt)[4]);//等价上句

int sum4d(int ar[][12][20][30],int rows); // 声明一个指向多维数组的指针，只能省略最左边括号中的值
int sum4d(int (*ar)[12][20][30],int rows); // 等价上句,ar指向一个 12 x 20 x 30 的int数组
```

# 变长数组VLA
变长数组的变不是可以修改已经创建的数组的大小。变长数组一旦创建，它的大小是保持不变的。变指的是，在创建数组时，可以使用变量指定数组的维度。
```c
int sum2d(int rows,int cols,int ar[rows][cols]); // rows　和　cols 必须在 ar 前面
int sum2d(int rows,int cols,int ar[rows][cols]){
    int r;
    int c;
    int tot = 0;
    for(r = 0;r < rows;r++){
        for(c = 0;c < cols;c++){
            tot += ar[r][c];
        }
    }
    return tot;
}
```

# 复合字面量
提供临时需要的值的一种手段
```c
(int []){20,30,40}
(int [2][4]){{1,2,3,-9},{4,5,6,-9}}
```
