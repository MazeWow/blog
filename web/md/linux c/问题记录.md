# 数组下标为什么从0开始而不是从1开始?
c语言在早期设计时的主要客户就是那些编译器设计者，在他们脑子里，偏移量这个概念已经根深蒂固。
`arr[0]`就是数组地址，`arr[1]`就是偏移一个单位，所以数组下标设计成了从0开始。

# 浮点数是硬件直接支持的

# auto关键字显然就是摆设

# float 被自动扩展为double

# 不允许函数嵌套
这简化了编译器

# register 优化变量的包袱丢给了程序员

# 在c语言编程中，程序员必须管理动态内存的使用，创建各种大小的数组，测试数组边界，并进行范围测试

# c 语言并没有定义I/O,而是由库函数提供

# c 预处理器1972加入
- 提供字符串替换
- 提供头文件`(*.h)`包含
- 通用代码模板的扩展
- 宏最好只用于命名常量，并为一些适当的结构提供简洁的记法
- 千万别用c预处理器修改语言的基础结构
- 空格带来的影响

```c
#define a(y) a_expanded(y)
a(x);// 被拓展为 a_expanded(x)
```
区别于
```c
#define a (y) a_expanded(y)
a(x); // 被拓展为　(y) a_expanded(y)(x)
```

# 可移植的代码
- 只使用已确定的特性
- 不突破任何由编译器实现的限制
- 不产生任何依赖由编译器定义的或未确定的或未定义的特性的输出

# 运行库
遵循标准的编译器必须提供的库函数列表，它们是标准所规定的辅助和实用函数。

# 更适合const原意的应该是readonly
