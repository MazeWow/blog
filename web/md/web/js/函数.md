# 函数定义
- 普通 函数声明 会被前置
    ```js
    function abs(x) {
        ...
    }
    ```
- 赋值 等价上一种 结尾加 ;
    ```js
    var abs = function (x) {
        ...
    };
    ```
- 立即调用函数表达式 IIFE

    ```javascript
    var area = (
    	function(){
    		var width = 10;
    		var height = 10;
    		return width * height;
    	}()
    );
    ```

- Function构造器
    ```js
    var func = new Function('a','b','console.log(a+b);');　//  调用func(1,2); //3
     // 等价
    var func = Function('a','b','console.log(a+b);');
    ```
# 参数
- 基本类型是作为值穿入,对象作为引用传入
- 传入的参数比定义的少也没有问题，形参接收到的值为 : undefined

## arguments 不定参数
- arguments[0] === a
- foo.name 函数名
- foo.length 形参个数
- arguments.length 实参个数
    ```js
    // foo(a[, b], c)
    // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
    function foo(a, b, c) {
        if (arguments.length === 2) {
            // 实际拿到的参数是a和b，c为undefined
            c = b; // 把b赋给c
            b = null; // b变为默认值
        }
        console.log(arguments.callee === foo); //true
    }
    foo(1,2);
    console.log(foo.length); //3
    console.log(foo.name);   //foo
    ```

## rest参数 ES6
- 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？
ES6标准引入了rest参数，上面的函数可以改写为：
    ```js
    function foo(a, b, ...rest) {
        console.log('a = ' + a);
        console.log('b = ' + b);
        console.log(rest);
    }

    foo(1, 2, 3, 4, 5);
    // 结果:
    // a = 1
    // b = 2
    // Array [ 3, 4, 5 ]

    foo(1);
    // 结果:
    // a = 1
    // b = undefined
    // Array []
    ```
- rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。
如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。

# 变量
## 全局变量
- JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性
- JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。
    ```js
    'use strict';

    var course = 'Learn JavaScript';
    alert(course); // 'Learn JavaScript'
    alert(window.course); // 'Learn JavaScript'

    function foo() {
        alert('foo');
    }
    foo(); // 直接调用foo()
    window.foo(); // 通过window.foo()调用
    ```
- const 常量 ES6
    ```js
    'use strict';
    const PI = 3.14;
    PI = 3; // 某些浏览器不报错，但是无效果！
    PI; // 3.14
    ```

## 命名空间
- 全局减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中
    ```js
    // 唯一的全局变量MYAPP:
    var MYAPP = {};

    // 其他变量:
    MYAPP.name = 'myapp';
    MYAPP.version = 1.0;

    // 其他函数:
    MYAPP.foo = function () {
        return 'foo';
    };
    ```
## 局部作用域
- JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的
    ```js
    'use strict';
    function foo() {
        for (var i=0; i<100; i++) {
            //
        }
        i += 100; // 仍然可以引用变量i
    }
    ```
- let (ES6) 用于申明块级作用域变量
    ```js
    'use strict';
    function foo() {
        var sum = 0;
        for (let i=0; i<100; i++) {  // i 是快级作用域
            sum += i;
        }
        i += 1; // SyntaxError
    }
    ```
## 变量提升
- JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量提升到函数顶部：
    ```js
    'use strict';
    function foo() {
        var x = 'Hello, ' + y;
        alert(x);
        var y = 'Bob';
    }
    foo();

    // js
    function foo() {
        var y; // 提升变量y的申明
        var x = 'Hello, ' + y;
        alert(x);
        y = 'Bob';
    }
    ```
    虽然是strict模式，但语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。

- 在函数内部首先申明所有变量，用一个var申明函数内部用到的所有变量
    ```js
    function foo() {
        var
            x = 1, // x初始化为1
            y = x + 1, // y初始化为2
            z, i; // z和i为undefined
        // 其他语句:
        for (i=0; i<100; i++) {
            ...
        }
    }
    ```


## 函数嵌套
- 内部函数可以访问外部函数定义的变量，反过来则不行
    ```js
    'use strict';
    function foo() {
        var x = 1;
        function bar() {
            var y = x + 1; // bar可以访问foo的变量x!
        }
        var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
    }
    ```
- 函数内变量重名 函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量
    ```js
    'use strict';
    function foo() {
        var x = 1;
        function bar() {
            var x = 'A';
            alert('x in bar() = ' + x); // 'A'
        }
        alert('x in foo() = ' + x); // 1
        bar();
    }
    ```

# 函数返回
- 自动分号机制
    ```js
    function foo() {
        return; // 自动添加了分号，相当于return undefined;
            { name: 'foo' }; // 这行语句已经没法执行到了
    }
    // vs
    function foo() {
        return { // 这里不会自动加分号，因为{表示语句尚未结束
            name: 'foo'
        };
    }
    ```


# 对象方法
- 在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。
```js
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};
xiaoming.age; // function xiaoming.age()
xiaoming.age(); // 今年调用是25,明年调用就变成26了
```
拆开写：
```js
function getAge() {
    var y = new Date().getFullYear();
    return y - this.birth;
}

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: getAge
};

xiaoming.age(); // 25, 正常结果
getAge(); // NaN
```

## this 指向谁?
单独调用函数getAge()怎么返回了NaN？请注意，我们已经进入到了JavaScript的一个大坑里。
JavaScript的函数内部如果调用了this，那么这个this到底指向谁？
答案是，视情况而定！
如果以对象的方法形式调用，比如`xiaoming.age()`，该函数的this指向被调用的对象，也就是xiaoming，这是符合我们预期的。
如果单独调用函数，比如`getAge()`，此时，该函数的this指向全局对象，也就是window。
坑爹啊！
更坑爹的是，如果这么写：

```js
var fn = xiaoming.age; // 先拿到xiaoming的age函数
fn(); // NaN
```
也是不行的！**要保证this指向正确，必须用obj.xxx()的形式调用！**

由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：

```js
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var y = new Date().getFullYear();
        return y - this.birth;
    }
};

var fn = xiaoming.age;
fn(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```
这个决定只是让错误及时暴露出来，并没有解决this应该指向的正确位置。
有些时候，喜欢重构的你把方法重构了一下：

```js
'use strict';

var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - this.birth;
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // Uncaught TypeError: Cannot read property 'birth' of undefined
```
结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）
修复的办法也不是没有，我们用一个that变量首先捕获this：

```js
'use strict';
var xiaoming = {
    name: '小明',
    birth: 1990,
    age: function () {
        var that = this; // 在方法内部一开始就捕获this
        function getAgeFromBirth() {
            var y = new Date().getFullYear();
            return y - that.birth; // 用that而不是this
        }
        return getAgeFromBirth();
    }
};

xiaoming.age(); // 25
```
用var that = this;，你就可以放心地在方法内部定义其他函数，而不是把所有语句都堆到一个方法中。


# 调用方式
`foo();`直接调用
`o.method();`方法调用
`new Foo();`构造器
`func.call(o);` call/apply/bind 调用

# 函数里的this
```
var o = {
    	 prop:37,
    	 f:function(){
    	    	 return this.prop;
    	 }
};
console.log(o.f());
```
this并不关心对象是什么,如何创建的
```
var o = {prop:37};
function independent(){
    return this.prop;
}
o.f = independent;
console.log(o.f());
```

原型链上的this
```js
var o = {f:function(){return this.a + this.b;}};
var p = Object.create(o);
p.a = 1;
p.b = 4;
console.log(p.f()); // p ---> a,p对象的原型链上的this也是指代p对象
```
set 与 get 函数里的this
```js
function modulus(){
    return Math.sqrt(this.re * this.re + this.im * this.im);
}
var o = {
    	 re:2,
    	 im:8,
    	 get phase(){
    	    	 return Math.atan2(this.im,this.re);
    	 }
}
Object.defineProperty(o,'modulus',{get:modulus,enumerable:true,configurable:true});
console.log(o.phase);
console.log(o.modulus);
```
构造函数里this
```js
function MyClass(){
    this.a = 37;
}
var o = new MyClass();
console.log(o.a);  //37

function C2(){
    this.a = 37;
    return {a:38};
}
var p = new C2();
console.log(p.a); //38
```
call/apply方法与this
```js
function add(c,d){
return this.a + this.b + c + d;
}
var o = {a:1,b:3};
console.log(add.call(o,5,7));	//1 + 3 + 5 + 7 = 16  call是直接传参
console.log(add.apply(o,[10,20])); //1 +3 + 10 + 20 = 34    apply是传一个参数数组进去
function bar(){
    return Object.prototype.toString.call(this);
}
console.log(bar.call(7));	//[object Number]
```
bind 后的this指向不会变了
```js
function f(){
    return this.a;
}
var g = f.bind({a:"test"});
console.log(g());	//test
var o = {a:37,f:f,g:g};
console.log(o.f());	//37
console.log(o.g()); //test
```
利用apply()，我们还可以动态改变函数的行为。

JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。

现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：

```js
var count = 0;
var oldParseInt = parseInt; // 保存原函数

window.parseInt = function () {
    count += 1;
    return oldParseInt.apply(null, arguments); // 调用原函数
};

// 测试:
parseInt('10');
parseInt('20');
parseInt('30');
count; // 3
```

# 改变图像
```html
<img id="myimage" onclick="changeImage()" src="/images/pic_bulboff.gif" width="100" height="180">
<script>
    element = document.getElementById('myimage');
    element.src="/images/pic_bulbon.gif";
</script>
```

# 改变样式
```javascript
x = document.getElementById("demo") // 找到元素
x.style.color = "#ff0000";          // 改变样式
```

# 改变值
```javascript
<input id="demo" type="text">
<script>
var x = document.getElementById("demo").value;
</script>
```

# 字符串属性和方法
```javascript
constructor	返回创建字符串属性的函数
length	返回字符串的长度
prototype	允许您向对象添加属性和方法

charAt()	返回指定索引位置的字符
charCodeAt()	返回指定索引位置字符的 Unicode 值
concat()	连接两个或多个字符串，返回连接后的字符串
fromCharCode()	将 Unicode 转换为字符串
indexOf()	返回字符串中检索指定字符第一次出现的位置
lastIndexOf()	返回字符串中检索指定字符最后一次出现的位置
localeCompare()	用本地特定的顺序来比较两个字符串
match()	找到一个或多个正则表达式的匹配
replace()	替换与正则表达式匹配的子串
search()	检索与正则表达式相匹配的值
slice()	提取字符串的片断，并在新的字符串中返回被提取的部分
split()	把字符串分割为子字符串数组
substr()	从起始索引号提取字符串中指定数目的字符
substring()	提取字符串中两个指定的索引号之间的字符
toLocaleLowerCase()	根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射
toLocaleUpperCase()	根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射
toLowerCase()	把字符串转换为小写
toString()	返回字符串对象值
toUpperCase()	把字符串转换为大写
trim()	移除字符串首尾空白
valueOf()	返回某个字符串对象的原始值
```
