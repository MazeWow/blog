# 函数定义
- 普通 函数声明 会被前置
    ```js
    function abs(x) {
        ...
    }
    ```
- 赋值 等价上一种 结尾加 ;
    ```js
    var abs = function (x) {
        ...
    };
    ```
- 立即调用函数表达式 IIFE

    ```javascript
    var area = (
    	function(){
    		var width = 10;
    		var height = 10;
    		return width * height;
    	}()
    );
    ```

- Function构造器
    ```js
    var func = new Function('a','b','console.log(a+b);');　//  调用func(1,2); //3
     // 等价
    var func = Function('a','b','console.log(a+b);');
    ```
# 参数
- 基本类型是作为值穿入,对象作为引用传入
- 传入的参数比定义的少也没有问题，形参接收到的值为 : undefined

## arguments 不定参数
- arguments[0] === a
- foo.name 函数名
- foo.length 形参个数
- arguments.length 实参个数
    ```js
    // foo(a[, b], c)
    // 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：
    function foo(a, b, c) {
        if (arguments.length === 2) {
            // 实际拿到的参数是a和b，c为undefined
            c = b; // 把b赋给c
            b = null; // b变为默认值
        }
        console.log(arguments.callee === foo); //true
    }
    foo(1,2);
    console.log(foo.length); //3
    console.log(foo.name);   //foo
    ```

## rest参数 ES6
- 为了获取除了已定义参数a、b之外的参数，我们不得不用arguments，并且循环要从索引2开始以便排除前两个参数，这种写法很别扭，只是为了获得额外的rest参数，有没有更好的方法？
ES6标准引入了rest参数，上面的函数可以改写为：
    ```js
    function foo(a, b, ...rest) {
        console.log('a = ' + a);
        console.log('b = ' + b);
        console.log(rest);
    }

    foo(1, 2, 3, 4, 5);
    // 结果:
    // a = 1
    // b = 2
    // Array [ 3, 4, 5 ]

    foo(1);
    // 结果:
    // a = 1
    // b = undefined
    // Array []
    ```
- rest参数只能写在最后，前面用...标识，从运行结果可知，传入的参数先绑定a、b，多余的参数以数组形式交给变量rest，所以，不再需要arguments我们就获取了全部参数。
如果传入的参数连正常定义的参数都没填满，也不要紧，rest参数会接收一个空数组（注意不是undefined）。

# 变量
## 全局变量
- JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性
- JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。
    ```js
    'use strict';

    var course = 'Learn JavaScript';
    alert(course); // 'Learn JavaScript'
    alert(window.course); // 'Learn JavaScript'

    function foo() {
        alert('foo');
    }
    foo(); // 直接调用foo()
    window.foo(); // 通过window.foo()调用
    ```
- const 常量 ES6
    ```js
    'use strict';
    const PI = 3.14;
    PI = 3; // 某些浏览器不报错，但是无效果！
    PI; // 3.14
    ```

## 命名空间
- 全局减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中
    ```js
    // 唯一的全局变量MYAPP:
    var MYAPP = {};

    // 其他变量:
    MYAPP.name = 'myapp';
    MYAPP.version = 1.0;

    // 其他函数:
    MYAPP.foo = function () {
        return 'foo';
    };
    ```
## 局部作用域
- JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的
    ```js
    'use strict';
    function foo() {
        for (var i=0; i<100; i++) {
            //
        }
        i += 100; // 仍然可以引用变量i
    }
    ```
- let (ES6) 用于申明块级作用域变量
    ```js
    'use strict';
    function foo() {
        var sum = 0;
        for (let i=0; i<100; i++) {  // i 是快级作用域
            sum += i;
        }
        i += 1; // SyntaxError
    }
    ```
## 变量提升
- JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量提升到函数顶部：
    ```js
    'use strict';
    function foo() {
        var x = 'Hello, ' + y;
        alert(x);
        var y = 'Bob';
    }
    foo();

    // js
    function foo() {
        var y; // 提升变量y的申明
        var x = 'Hello, ' + y;
        alert(x);
        y = 'Bob';
    }
    ```
    虽然是strict模式，但语句var x = 'Hello, ' + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。

- 在函数内部首先申明所有变量，用一个var申明函数内部用到的所有变量
    ```js
    function foo() {
        var
            x = 1, // x初始化为1
            y = x + 1, // y初始化为2
            z, i; // z和i为undefined
        // 其他语句:
        for (i=0; i<100; i++) {
            ...
        }
    }
    ```


## 函数嵌套
- 内部函数可以访问外部函数定义的变量，反过来则不行
    ```js
    'use strict';
    function foo() {
        var x = 1;
        function bar() {
            var y = x + 1; // bar可以访问foo的变量x!
        }
        var z = y + 1; // ReferenceError! foo不可以访问bar的变量y!
    }
    ```
- 函数内变量重名 函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量
    ```js
    'use strict';
    function foo() {
        var x = 1;
        function bar() {
            var x = 'A';
            alert('x in bar() = ' + x); // 'A'
        }
        alert('x in foo() = ' + x); // 1
        bar();
    }
    ```

# 函数返回
- 自动分号机制
    ```js
    function foo() {
        return; // 自动添加了分号，相当于return undefined;
            { name: 'foo' }; // 这行语句已经没法执行到了
    }
    // vs
    function foo() {
        return { // 这里不会自动加分号，因为{表示语句尚未结束
            name: 'foo'
        };
    }
    ```
