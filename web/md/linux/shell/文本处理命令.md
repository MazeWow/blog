# sort
- `-f` 忽略大小写
- `-b` 忽略排序起始处的空白
- `-m` 将两个已排序数据文件合并
- `-g` 转换为浮点数后排序

```bash
sort file1.txt file2.txt > sorted.txt # 将两个文件里的内容排好序，存入另一个文件

sort -t: -k3 -n /etc/passwd # -t 以:为分隔符，-k 选择第3列作为排序依据
root:x:0:0:root:/root://usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...

du -sh * | sort -nr # -n 以数字大小排序，-r 反转排序方向
80K	lib
40K	src
32K	cky
20K	main.c
16K	include
12K	hello
4.0K	shell
4.0K	README.md
4.0K	Makefile
0	text.txt
```

# grep
- `grep [options] pattern [file]`
- `-v` 反向搜索,显示不匹配pattern的
- `-n` 显示行号
- `-c` 统计有多少匹配的行
- `-e` 指定多个pattern
- `-r` 递归

# wc
- 统计 行数 词数 字节数
```bash
➜  shell git:(master) wc < /etc/passwd
  46   78 2590
```

# uniq 去重
```bash
cat uniq.txt 
bash
foss
hack
hack

uniq uniq.txt # 去重
bash
foss
hack

uniq -u uniq.txt # 只显示唯一的行 
bash
foss

uniq -c uniq.txt # 统计出现行数
      1 bash
      1 foss
      2 hack
      1 

uniq -d uniq.txt # 找出重复的行
hack

uniq -s2 -w2 -c uniq_data.txt # -s 指定跳过两个字符，-w 指定只对比多少个字符
      1 u:01:gnu
      1 d:04:linux
      2 u:01:bash

uniq -z file.txt | xargs -0 rm # -z 给每行添加 \0 终结符，用以和 xargs -0 配合使用，使得每行被当做一个参数，而不是被空格隔开的好几个参数
```





