# sort
- `-f` 忽略大小写
- `-b` 忽略排序起始处的空白
- `-m` 将两个已排序数据文件合并
- `-g` 转换为浮点数后排序

```bash
sort file1.txt file2.txt > sorted.txt # 将两个文件里的内容排好序，存入另一个文件

sort -t: -k3 -n /etc/passwd # -t 以:为分隔符，-k 选择第3列作为排序依据
root:x:0:0:root:/root://usr/bin/zsh
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
...

du -sh * | sort -nr # -n 以数字大小排序，-r 反转排序方向
80K	lib
40K	src
32K	cky
20K	main.c
16K	include
12K	hello
4.0K	shell
4.0K	README.md
4.0K	Makefile
0	text.txt
```

# grep
- `grep [options] pattern [file]`
- `-v` 反向搜索,显示不匹配pattern的
- `-n` 显示行号
- `-c` 统计有多少匹配的行
- `-e` 指定多个pattern
- `-r` 递归

# wc
- 统计 行数 词数 字节数
```bash
➜  shell git:(master) wc < /etc/passwd
  46   78 2590
```

# uniq 去重
```bash
cat uniq.txt 
bash
foss
hack
hack

uniq uniq.txt # 去重
bash
foss
hack

uniq -u uniq.txt # 只显示唯一的行 
bash
foss

uniq -c uniq.txt # 统计出现行数
      1 bash
      1 foss
      2 hack
      1 

uniq -d uniq.txt # 找出重复的行
hack

uniq -s2 -w2 -c uniq_data.txt # -s 指定跳过两个字符，-w 指定只对比多少个字符
      1 u:01:gnu
      1 d:04:linux
      2 u:01:bash

uniq -z file.txt | xargs -0 rm # -z 给每行添加 \0 终结符，用以和 xargs -0 配合使用，使得每行被当做一个参数，而不是被空格隔开的好几个参数
```


# 排序
http://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html
`sort -n`           将0-9识别为数字进行排序
`sort -t':' -k 3`   -t指定分割的字段，-k 3 表示根据分割的第三段排序
`sort -r`          逆序排列
例子：
我想让facebook.txt按照员工工资降序排序，如果员工人数相同的，则按照公司人数升序排序：
`$ sort -n -t' ' -k 3r -k 2 facebook.txt`
baidu     100     5000
google    110     5000
sohu      100     4500
guge      50      3000
从公司英文名称的第二个字母开始进行排序
`$ sort -t ' ' -k 1.2 facebook.txt`
baidu     100     5000
sohu      100     4500
google    110     5000
guge      50      3000
只针对公司英文名称的第二个字母进行排序，如果相同的按照员工工资进行降序排序
`$ sort -t ' ' -k 1.2,1.2 -k 3,3nr facebook.txt`
baidu  100  5000
google 110  5000
sohu   100  4500
guge   50   3000

# grep搜索文本
`grep pattern files`  搜索匹配pattern的内容
`grep -r pattern dir`  递归搜索dir中匹配parttern的内容
`grep -v  file.txt`  输出没匹配到文本的行
`grep -n  file.txt`  显示行号
`grep -E '219|216' data.doc` 匹配带有 219 或者 216的行
`egrep Posix_regexp file.txt` 使用POSIX拓展正则表达式
`px aux |grep ngnix` 搜索匹配到ngnix的行

# 去重
这个命令读取输入文件，并比较相邻的行。在正常情况下，第二个及以后更多个重复行将被删去
uniq  -c  显示输出中，在每行行首加上本行在文件中出现的次数

# cut 提取列 :基本被awk替代
cut -f 列数 -d 分割符 file.txt
例子：grep "/bin/bash" /etc/passwd |grep -v "root" |cut -f 1 -t :

# 查询某个文件的所有git提交记录详情
```bash
git log mcs_db_install.sql | grep commit | awk '{print "git show " $2}' | sh >> mcs_db_install-git-show-log
```
# 统计某个文件夹下所有.php文件中代码行数
```bash
find ./ -name "*.php"|xargs cat|grep -v ^$|wc -l
```
# 删除windows系统编辑文本产生的不可见字符`^M`
```bash
touch love_tmp.c
sed 's/^M//' $1 > love_tmp.c
mv love_tmp.c $1
```
操作符	说明	举例

`^M` 的输入方法为 `Ctrl + v` 再加上 `Ctrl + m`
`cat -v love.c` 可用来查看一个文件，特殊字符也会显示出来



