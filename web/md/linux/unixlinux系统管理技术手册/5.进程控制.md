# 进程组成部分 (内核的内部数据结构记录的)
- 进程地址空间映射
- 当前状态(睡眠 停止 可运行)
- 进程优先级
- 进程已用资源信息
- 进程打开的文件和网络端口信息
- 进程的信号掩码 (一个记录 确定要封锁哪些信号)
- 进程的属主

# PID

# PPID
- linux 没有提供创建新进程去运行某个特定程序的系统调用，现有进程必须克隆自身去创建一个新进程，克隆出的进程能够把它正在运行的那个程序替换成另一个不同程序
- 新进程的 PPID 就是那个克隆自身的进程的PID, 它可以用来回溯进程的来源(是一个shell还是另一个程序)

# UID 和 EUID
- 进程的所属用户  和  有效所属用户

# GID 和 EGID
- 进程的用户组ID 和 有效用户组ID

# 进程的生命周期
- 进程 A 调用 `fork` 来复制自身,得到进程 B , 对于 A 进程 fork 返回 B 的PID,对于B 进程 fork 返回 0
- `fork`之后 , B 进程可以调用 `exec`族 函数 , 来执行新的程序, 这些调用能改变 B 进程的 .text (程序正文)，并把内存段重置为预先定义的初始状态
- 除了内核在初始化时创建的几个内核进程, 其余的进程都是 `init` 进程的子进程
- B 进程调用 `_exit` 例程来通知内核 结束进程 , A 进程必须调用 wait 来确认 B 的结束, 但是如果 A 进程已经早于 B 进程结束的话，B 进程就成了孤儿进程, 则由 `init` 来成为B的父进程 , 调用`wait`来清理

# 信号
- 信号是进程级的中断请求
- 作为一种通信手段，进程之间可以发送信号
- 当输入`Ctrl + C` `Ctrl + z`时，可以由终端驱动程序发送信号去终止/中断/挂起进程
- 可以由管理员 使用 kill 发送信号来达到各种效果
- 当进程出错，比如`0作除数`,可以由进程来发送信号
- 可以由内核发送信号，通知一个进程 "有受关注的条件"出现，比如子进程死亡，或者I/O通道上有数据
- 进程收到信号后，可以调用自身已经写好的处理这个信号的例程来处理
- 当然，如果没有写处理例程的话，内核就会代表该进程采取默认措施，比如有些信号会终止进程
- 有些信号就会产生 core 文件 (内存转储文件 core dump), 就是将当时进程的内存状态保存下来， core 理解为内存 ，是旧词沿用下来的含义
- 为了防止收到信号，进程也可以选择 ignore 或者 block 某些信号
