# 小论
- 运行效率不应该成为脚本编写的关注重点，清晰可读性才是重点
- shell脚步简单易用，linux标配，但是高端复杂的脚本的编写，使用Perl和Python会更加给力,但是缺点在于，建立它们的环境要麻烦些

# shell基础
- 设置编辑模式
    ```
    ➜  ~ set -o vi
    ```

## 管道和重定向
- 每个进程都有三个流,`stdin` `stdout` `stderr`,进程不在意这三个流来自哪里，又通向哪里，它们可能链接到一个终端，一个文件，一条网络链接，或者另一个进程的流
- 每个流的命名叫做`文件描述符`，它们依次是0,1,2
- 三个流的默认指向都是终端
- `>` `<` `>>` 是重定向，能改变流的指向
    ```
    ➜  ~ echo "this is a test message" /tmp/mymessage /*重定向输出到文件*/
    ➜  ~ mail -s "Mail test" cky < /tmp/mymessage /*使用文件里内容发送邮件*/
    ```
- 将错误输出重定向
    ```
    ➜  ~ find / -name core /*没有重定向，stdout与stderr都输出在屏幕*/
    find: ‘/boot/efi’: 权限不够
    /dev/core
    find: ‘/sys/kernel/debug’: 权限不够
    find: ‘/var/spool/rsyslog’: 权限不够

    ➜  ~ find / -name core /tmp/test_output /*只将stdout重定向到文件,stderr还是输出到了屏幕*/
    find: ‘/boot/efi’: 权限不够
    find: ‘/sys/kernel/debug’: 权限不够

    ➜  ~ find / -name core >& /tmp/test_output /*将stdout与stderr都输出到文件*/
    ➜  ~ cat /tmp/test_output
    find: ‘/boot/efi’: 权限不够
    /dev/core
    find: ‘/sys/kernel/debug’: 权限不够
    find: ‘/var/spool/rsyslog’: 权限不够
    find: ‘/var/spool/exim4’: 权限不够
    find: ‘/var/spool/cups’: 权限不够
    find: ‘/var/spool/cron/crontabs’: 权限不够

    ➜  ~ find / -name core 2/tmp/null       /*将stderr输出到黑洞，将stdout输出到屏幕*/
    /dev/core
    /usr/share/atom/resources/app/apm/node_modules/git-utils/deps/libgit2/tests/core
    /usr/src/linux-headers-4.10.0-20-generic/include/config/serial/core
    /usr/src/linux-headers-4.10.0-20-generic/include/config/mlxsw/core
    /usr/src/linux-headers-4.10.0-20-generic/include/config/mlx5/core
    /usr/src/linux-headers-4.10.0-20-generic/include/config/core
    ```

- 将一条命令的stdout链接到另一条命令的stdin
    ```
    ➜  ~ ps -ef | grep ssh                
    cky       1324  1245  0 4月27 ?       00:00:00 /usr/bin/ssh-agent /usr/bin/sogou-session /usr/bin/im-launch /usr/lib/gnome-session/run-systemd-session ubuntu-session.target
    cky       1454  1183  0 4月27 ?       00:00:00 /usr/bin/gnome-keyring-daemon --start --components ssh
    cky      32116  3823  0 18:22 pts/0    00:00:00 grep --color=auto --exclude-dir=.bzr --exclude-dir=CVS --exclude-dir=.git --exclude-dir=.hg --exclude-dir=.svn ssh
    ➜  ~ cut -d: -f7 < /etc/passwd|sort -u
    /bin/bash
    /bin/false
    /bin/sync
    /usr/bin/zsh
    /usr/sbin/nologin
    ```
- && 与 ||
    ```
    ➜  workspace echo "hello world" /tmp/t2
    ➜  workspace ls -alh && cat /tmp/t2 /*前一个命令执行成功，后面的命令才会执行*/
    总用量 28K
    drwxr-xr-x  7 cky cky 4.0K 4月  27 14:53 .
    drwxr-xr-x 32 cky cky 4.0K 4月  28 20:27 ..
    drwxr-xr-x  8 cky cky 4.0K 2月  22 22:24 blog
    drwxr-xr-x  3 cky cky 4.0K 4月  27 12:07 cky
    drwxr-xr-x 26 cky cky 4.0K 4月  27 21:26 linux
    drwxr-xr-x  3 cky cky 4.0K 4月  20 18:59 note
    drwxr-xr-x  3 cky cky 4.0K 4月  14 16:28 sudoku
    hello world
    ➜  workspace ls -alh || cat /tmp/t2 /*前一个命令执行失败，后面的命令才会执行*/
    总用量 28K
    drwxr-xr-x  7 cky cky 4.0K 4月  27 14:53 .
    drwxr-xr-x 32 cky cky 4.0K 4月  28 20:27 ..
    drwxr-xr-x  8 cky cky 4.0K 2月  22 22:24 blog
    drwxr-xr-x  3 cky cky 4.0K 4月  27 12:07 cky
    drwxr-xr-x 26 cky cky 4.0K 4月  27 21:26 linux
    drwxr-xr-x  3 cky cky 4.0K 4月  20 18:59 note
    drwxr-xr-x  3 cky cky 4.0K 4月  14 16:28 sudoku
    ```

# 变量和引用
- 不要在变量两边留空白，否则shell会把变量当做命令
    ```
    ➜  ~ etcdir='/etc'
    ➜  ~ echo $etcdir
    /etc
    ```
- 使用`{}`拓展变量
    ```
    ➜  ~ rev=8
    ➜  ~ echo "the ${rev}th version of config.conf"
    the 8th version of config.conf
    ```

- `''`与`""`的区别 : `''`是不解析`{}` `$` `*` `?`的
    ```
    ➜  ~ myname="codekissyoung"
    ➜  ~ echo "i am ${myname}"
    i am codekissyoung
    ➜  ~ echo 'i am ${myname}'
    i am ${myname}
    ➜  ~ echo "there was `wc -l /etc/passwd` lines in passwd file" /* `` 可以被解析，它的意思是把里面的字符串执行，返回结果*/
    there was 45 /etc/passwd lines in passwd file
    ```


- 环境变量
    ```
    ➜  ~ export abc=123 /*声明一个环境变量*/
    ➜  ~ env /*输出所有环境变量*/
    XDG_SEAT_PATH=/org/freedesktop/DisplayManager/Seat0
    XDG_CONFIG_DIRS=/etc/xdg/xdg-ubuntu:/etc/xdg
    LC_TELEPHONE=zh_CN.UTF-8
    LANG=zh_CN.UTF-8
    DISPLAY=:0
    SHLVL=2
    LOGNAME=cky
    LANGUAGE=zh_CN:zh:en_US:en
    INVOCATION_ID=d1774be268ce4fcc816f39a929989c7f
    MANDATORY_PATH=/usr/share/gconf/ubuntu.mandatory.path
    PWD=/home/cky
    ... /*省略部分代码*/
    abc=123
    ```
用户登录终端时设置的那些环境变量都在`~/profile`和`~/.bash_profile`里，而像`PWD`这样的环境变量，由shell自动维护


# 过滤器命令
- 过滤器命令接受一个或者多个文件名输入，如果在一个文件名都没提供的时候，它们从`stdin`里读取数据
- sort排序
    ```
    -b 忽略开头空白
    -f 忽略大小写
    -t 设定分割符(默认空白)，将一行字符串分割
    -k 指定按某个分割的列排序
    -u 重复记录只输出一次
    -n 按数值大小比较，而不是ascii字符串
    -r 顺序反转，从大到小排序

    ➜  ~ sort -t: -n -k3,3 /etc/passwd
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    bin:x:2:2:bin:/bin:/usr/sbin/nologin
    sys:x:3:3:sys:/dev:/usr/sbin/nologin
    sync:x:4:65534:sync:/bin:/bin/sync

    ➜  ~ sort -t: -k3,3 /etc/passwd  
    root:x:0:0:root:/root:/bin/bash
    daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
    uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
    systemd-timesync:x:100:102:systemd Time Synchronization,,,:/run/systemd:/bin/false
    cky:x:1000:1000:cky,,,:/home/cky:/usr/bin/zsh
    ```
- cat
    ```
    -d 改变限定符(默认是[Tab]),该限定符将一行数据切割成几部分
    -f 指定输出里面包含那几个部分
    ```

- uniq 重复行只打印一次，通常这个命令接在sort命令后面运行
    ```
    -c 累计每行出现的次数
    -d 只显示重复行
    -u 只显示不重复行

    ➜  ~ cut -d: -f7 /etc/passwd|sort|uniq -c
          1 /bin/bash
         26 /bin/false
          1 /bin/sync
          1 /usr/bin/zsh
         16 /usr/sbin/nologin
    ```

- wc 统计行数，字数，字符数
    ```
    -l 只输出行数
    -w 只输出字数
    -c 只输出字节数

    ➜  ~ wc /etc/passwd
    45   76 2528 /etc/passwd
    ```

- tee 把输入复制到两个地方
    ```
    /* /dev/tty 表示本终端，整句意思是往本终端发一份，再给wc -l命令传一份*/
    ➜  ~ find /home/cky/workspace -name cky 2>/dev/null | tee /dev/tty|wc -l
    /home/cky/workspace/cky
    /home/cky/workspace/cky/cky
    2
    ```

- tail 读取文件
    ```
    -f 监控，命令不马上退出，而是等待着有新行被追加到文件末尾，然后打印它们
    ```

- grep 搜索文本
    ```
    -c 统计文件内有几处匹配到的
    -i 忽略大小写
    -v 打印不匹配行
    -l 只打印匹配到内容的文件的名字，而不是匹配的每一行
    -r 表示输入的路径是一个目录，匹配目录下的所有文件
    -n 输出匹配处在文件内的行数

    ➜  ~ grep -nr codekissyoung /home/cky/workspace/blog
    /home/cky/workspace/blog/function/common.php:32:			if($leaf == "codekissyoung.md"){
    /home/cky/workspace/blog/web/index.php:20:	$content = file_get_contents(MD_ROOT.'/codekissyoung.md');
    /home/cky/workspace/blog/web/md/unix/第一章-基础知识.md:12:参考`codekissyoung:x:1000:1000::/home/codekissyoung:/bin/zsh`
    /home/cky/workspace/blog/web/md/c/字符串.md:56:    "codekissyoung"
    /home/cky/workspace/blog/web/md/c/字符串.md:75:// array_str[3] : 0x7fff8107c818 : codekissyoung
    /home/cky/workspace/blog/web/md/c/字符串.md:103:printf("hello codekissyoung,where are you");
    /home/cky/workspace/blog/web/md/c/字符串.md:104:printf("hello"  " codekissyoung" ",where are you");
    /home/cky/workspace/blog/web/md/c/字符串.md:105:printf("hello codekissyoung"
    /home/cky/workspace/blog/web/md/c/字符串.md:110:# strlen("codekissyoung"); // 13

    ➜  ~ grep -cr codekissyoung /home/cky/workspace/blog|sort -t: -k2,2 -nr
    /home/cky/workspace/blog/web/md/linux/unixlinux系统管理技术手册/2.脚本和shell.md:12
    /home/cky/workspace/blog/web/md/linux/docker.md:8
    /home/cky/workspace/blog/web/md/c/字符串.md:6
    /home/cky/workspace/blog/web/md/php/Yii 安全.md:3
    /home/cky/workspace/blog/web/md/linux/git.md:3
    /home/cky/workspace/blog/web/md/codekissyoung.md:3
    /home/cky/workspace/blog/web/md/web/协议架构优化性能/discuz.md:1
    /home/cky/workspace/blog/web/md/web/js/jquery.md:1
    /home/cky/workspace/blog/web/md/web/htmlcss/常用标签.md:1
    /home/cky/workspace/blog/web/md/unix/第一章-基础知识.md:1
    /home/cky/workspace/blog/web/md/php/Yii 组件.md:1
    /home/cky/workspace/blog/web/md/php/wordpress.md:1
    /home/cky/workspace/blog/web/md/php/php 变量.md:1
    /home/cky/workspace/blog/web/md/php/php-api.md:1
    /home/cky/workspace/blog/web/md/linux/linux内核设计与实现/2.从内核出发.md:1
    /home/cky/workspace/blog/web/md/c/数据类型.md:1
    /home/cky/workspace/blog/web/md/c/底层概念.md:1
    /home/cky/workspace/blog/web/js.php:1
    /home/cky/workspace/blog/web/index.php:1
    /home/cky/workspace/blog/function/common.php:1
    /home/cky/workspace/blog/youziku-sdk-php-master/Youziku_PHP_SDK_Demo.rar:0
    ```

# bash 脚本编程
- hello 脚本
    ```
    #!/bin/bash
    echo "hello world!"
    ```
- 加可执行权限，运行
    ```
    chmod +x hello
    ./hello
    hello world!
    ```
- read
    ```
    #!/bin/bash
    # -n 消除了通常的换行符
    echo -n "enter your name:"
    read user_name
    # 判断user_name是否为空，注意if等指令与其他字符相邻，中间要加空格
    if [ -n "$user_name" ];then
    	echo $user_name;
    	exit 0
    else
    	echo "you do not enter username"
    	exit 1
    fi
    ```

- 命令行参数
    ```
    #!/bin/bash
    echo "脚本名字:$0"
    echo "第一个参数:$1"
    echo "总共的参数个数:$#"
    ```
    ```
    ➜  shell ./params xixi haha
    脚本名字:./params
    第一个参数:xixi
    总共的参数个数:2
    ```
