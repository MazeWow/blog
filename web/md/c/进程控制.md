# 基本概念
- 每个进程都有一个父进程
- 当父进程调用fork函数创建一个子进程而不调用wait函数时,一个僵尸进程就产生了
- fork这个函数的特别之处在于一次调用，两次返回，一次返回到父进程中，一次返回到子进程中

# 创建子进程 fork()

# 共享空间的子进程 vfork()


# 改变进程所有者
```
int setuid(uid_t uid);
int seteuid(uid_t uid);
int setgid(gid_t gid);
int setegid(gid_t gid);
```

# 调试多进程
## 设置跟踪流
```
(gdb)set follow-fork-mode [parent|child]
(gdb)set detach-on-fork [on|off]
```

## 使用gdb的attach命令



# 在进程中运行shell命令
```
#include <stdlib.h>
int system(const char * cmdstring);
```

# 获取子程序结束信息
```
#include <sys/wait.h>
pid_t wait(int *statloc);
```

# 僵尸进程
- 如果子进程先于父进程退出， 同时父进程又没有调用wait/waitpid，则该子进程将成为僵尸进程。

# 避免产生僵尸进程
```
```


# 输出进程统计信息
进程统计信息都储存在rusage这个统计资源结构体内
```
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/source.h>
pid_t wait3(int *statloc,int options,struct rusage *rusage);
pid_t wait4(pid_t pid,int *statloc,int options,struct rusage *rusage);

```
