# Single 单例模式
- 该对象可以被系统中任何对象使用
- 该对象不会存储在全局变量中
- 系统中有且只有一个该对象

```php
<?php
class Preferences {
	private $props = [];
	private static $instance;

	private function __construct(){}

	public function setProperty ( $key , $val ) {
		$this -> props[$key] = $val;
	}

	public function getProperty( $key ){
		return $this -> props[$key];
	}
	
	public static function getInstance(){
		if( empty( self::$instance ) ){
			self::$instance = new self();
		}
		return self::$instance;
	}
}

$pref = Preferences :: getInstance();
$pref -> setProperty("name","codekissyoung");

unset($pref);
$pref2 = Preferences :: getInstance();
print $pref2 -> getProperty("name")."\n";
```

# Factory Method 工厂模式
- 抽象类高于实现
- 工厂模式就是为了解决，在抽象时，如何创建对象实例，答案就是用特定的类来处理实例化

```php
<?php
abstract class AppEncoder {/*{{{*/
	abstract function encode();
}/*}}}*/

class BloggsApptEncoder extends AppEncoder {/*{{{*/
	function encode(){
		return "Appointment data encoded in BloggsCal format \n";
	}
}/*}}}*/

class MegaApptEncoder extends AppEncoder {/*{{{*/
	function encode(){
		return "Appointment data encoded in MegaCal format \n";
	}
}/*}}}*/

// 对象工厂 用于按需求生产对象
class CommsManager {/*{{{*/

	const BLOGGS = 1;
	const MEGA   = 2;
	private $mode = 1;

	function __construct( $mode ){
		$this -> mode = $mode;
	}

	function getHeaderText() {
		switch( $this -> mode ){
			case ( self::MEGA ):
				return "MegaCal header \n";
				break;
			default:
				return "BloggsCal header \n";
				break;
		}
	}

	function getApptEncoder(){
		switch( $this -> mode ){
			case (self::MEGA):
				return new MegaApptEncoder();
				break;
			default:
				return new BloggsApptEncoder();
				break;
		}
	}
}/*}}}*/

$comms = new CommsManager( CommsManager::MEGA );
$appEncoder = $comms -> getApptEncoder();
print $comms -> getHeaderText();
print $appEncoder -> encode();
```

- 缺点 : 工厂里面有很多条件语句，如果我们加入新协议，就又要加条件，如果要加入新方法，比如`getFooterText()`,又要每个可能生成的对象写一遍条件

```php
<?php
abstract class AppEncoder {/*{{{*/
	abstract function encode();
}/*}}}*/

class BloggsApptEncoder extends AppEncoder {/*{{{*/
	function encode(){
		return "Appointment data encoded in BloggsCal format \n";
	}
}/*}}}*/

class MegaApptEncoder extends AppEncoder {/*{{{*/
	function encode(){
		return "Appointment data encoded in MegaCal format \n";
	}
}/*}}}*/

// 对抽象工厂使用多态
abstract class CommsManager {/*{{{*/
	abstract function getHeaderText();
	abstract function getApptEncoder();
	abstract function getFooterText();
}/*}}}*/

class BloggsCommsManager extends CommsManager {
	function getHeaderText(){
		return "BloggsCal Header";
	}
	function getApptEncoder(){
		return new BloggsApptEncoder();
	}
	function getFooterText(){
		return "BloggsCal Footer";
	}
}

$blog = BloggsCommsManager::getApptEncoder();
print $blog -> encode();

```




# Abstract Factory 抽象工厂模式


# Prototype 原型模式









