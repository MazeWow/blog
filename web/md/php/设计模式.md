# 工厂模式
使用函数或者类方法生成对象，而不是在代码中直接 new !
使用工厂模式的一个考虑就是，在很多个地方使用了new 对象,如果对象有变,改起代码来不方便
```php
<?php
class  Factory {
    static function createDb(){
        $db = new Database ;
        return $db;
    }
}
Factory : : createDb();
```
# 单例模式
保证程序运行时，只能存在某个类的一个实例对象！
```php
class Mem extends Memcache{
    private static $mem_instance = null;
    private function __construct(){      //在外部就不能new对象了
        parent::__construct();
    }
    private function __clone(){}
    public static function get_mem_ins(){
        if(null === self::$mem_instance){
            self::$mem_instance = new Memcache;
        }
        return self::$mem_instance;
    }
}
$mem = Memcache::get_mem_ins();  //调用
```
# 注册器模式
用来将一些全局需要使用的类，变量挂载到注册树上，程序任何地方都可以通过注册器树取到想要的对象或值
```
class Register{
    protected static $objects;
    static function set($alias,$object){
        self::$objects[$alias] = $object;
    }
    static function __unset(){
        unset(self::$objects[$alias]);
    }
    public function get($alias){
        return slef::$objects[$alias];
    }
}
```
# 适配器模式
实现思路：定义一个接口约束Interface DB ,里面定义了要实现的方法,MySQL,MySQLi,PDO分别是这个接口的三种实现。
```
$db = new MySQL(...)|MySQLi(...)|PDO(...);    //三种实现任意切换
$db->connect();
$db->do_something();
$db->close();
```

# 策略模式
将一组特定的行为和算法封装成类,以适应某些特定的上下文环境,这就是策略模式,实现思路如下：
约定一个接口 interface Show{...} ,根据上下文环境,分别实现n个符合接口的策略类,
```
if(上下文1){
    new 策略1;
}
if(上下文2){
    new 策略2;
}
```
